#!/usr/bin/env python
import nltk.corpus
import re
import sys

def main():
    write(translate(read()))

def read():
    return [line.strip() for line in sys.stdin]

def translate(lines):
    return compose([remove_empty,
                    filter_text,
                    scene_stage_directions,
                    fold_stage_directions,
                    convert,
                    shared_verse_lines,
                    add_wrapper])(lines)

def remove_empty(lines):
    return filter(None, lines)

def filter_text(lines):
    start = lines.index('ACT 1. SCENE 1.1.')
    end = lines.index('*****')
    return lines[start:end]

def scene_stage_directions(lines):
    result = []
    at_scene_start = False
    stage_dir = []
    for line in lines:
        if at_scene_start:
            if re.match(r"^[A-Z '.,]+$", line):
                stage_dir.append(line)
            else:
                result.append(r'\stagedir{%s}' % ' '.join(stage_dir))
                result.append(line)
                at_scene_start = False
                stage_dir = []
        else:
            if re.match(r'^.*SCENE [0-9]+\.[0-9]\.$', line):
                at_scene_start = True
            result.append(line)
    return result

def fold_stage_directions(lines):
    result = []
    in_stage_dir = False
    stage_dir = None
    for line in lines:
        if in_stage_dir:
            stage_dir.append(line)
            if ']' in line:
                result.append(' '.join(stage_dir))
                in_stage_dir = False
                stage_dir = None
        else:
            if '[' in line and not ']' in line:
                in_stage_dir = True
                stage_dir = [line]
            else:
                result.append(line)
    return result

def shared_verse_lines(lines):
    dictionary = nltk.corpus.cmudict.dict()
    def parse_speech(line):
        m = re.match(r"^(\\[a-z]+ )?([A-Za-z.:;,\"' ?!()-]+)\\\\$", line)
        if not m:
            return None
        return {'prefix': m.group(1) or '', 'words': m.group(2)}
    def is_speech(line):
        return not not parse_speech(line)
    def speech_words(speech):
        return parse_speech(speech)['words']
    def is_complete(verse_line):
        def word_syllables(word):
            purged = re.sub(r'[^a-zA-Z]', '', word).lower()
            if purged in dictionary:
                candidates = dictionary[purged]
                return len([y for y in candidates[0] if y[-1].isdigit()])
            else:
                return len(re.sub(r'[^aeiou]', '', purged))
        def speech_syllables(speech):
            return sum(map(word_syllables, speech_words(speech).split()))
        return sum(map(speech_syllables, verse_line)) > 8
    def is_same_speaker(line):
        return is_speech(line) and parse_speech(line)['prefix'] == ''
    def phantom(lines):
        if not lines:
            return ''
        return r'\vinphantom{%s}' % ''.join(map(speech_words, lines))
    result = []
    verse_line = []
    for i in range(len(lines)):
        line = lines[i]
        if is_speech(line):
            verse_line.append(line)
            if is_complete(verse_line) or is_same_speaker(lines[i+1]):
                for j in range(0, len(verse_line)):
                    current = parse_speech(verse_line[j])
                    result.append(r'%s%s %s\\' % (current['prefix'], phantom(verse_line[0:j]), current['words']))
                verse_line = []
        else:
            result.append(line) # this will be out of place (too
            # early) if it is a stage direction in the middle of a
            # shared line
    return result

def convert(lines):
    return map(compose([normalize_prefix_direction_combos,
                        fix_broken_prefix]+
                       fix_insertions()+
                       speech_prefixes()+
                       [stage_direction,
                        verse,
                        acts,
                        scenes]),
               lines)

def normalize_prefix_direction_combos(line):
    return re.sub(r'^([A-Z]+) \[(.+)\]\.(.*)$', r'\1. [\2]\3', line)

def fix_broken_prefix(line):
    return re.sub(r'SUR\.--', r'SUR. --', line)

def fix_insertions():
    def make_fix(word):
        return lambda line: re.sub(r'^(.*)\[(%s)\](.*)$'%word, r'\1\2\3', line)
    return map(make_fix, ['my', 'a'])

def speech_prefixes():
    def speech_prefix(opts):
        orig, new = opts
        return lambda line: re.sub(r'^%s. (.+)$'%orig, r'\\%sspeaks \1'%new, line)
    return map(speech_prefix, prefix_defs())

def prefix_defs():
    return [('DOL', 'dol'),
            ('FACE', 'face'),
            ('SUB', 'subtle'),
            ('LOVE', 'lovewit'),
            ('KAS', 'kastril'),
            ('DRUG', 'drugger'),
            ('NAB', 'drugger'),
            ('ANA', 'ananias'),
            ('TRI', 'tribulation'),
            ('SUR', 'surly'),
            ('MAM', 'mammon'),
            ('DAP', 'dapper'),
            ('DAME P', 'pliant'),
            ('OFFI', 'officerone'),
            ('1 OFFI', 'officerone'),
            ('2 OFFI', 'officertwo')]

def stage_direction(line):
    return re.sub(r'^(.*)\[(.*)\](.*)$', r'\1\\direct*{\2}\3', line)

def verse(line):
    if re.match(r'^(\\[a-z]+ )?\\direct\*\{[^{]+\}$', line):
        # This line only has a stage direction on it (maybe preceeded
        # by a speech prefix).
        return line
    if re.match(r'^\\[A-Za-z]+\{.*\}$', line):
        return line
    return r'%s\\' % line

def acts(line):
    return re.sub(r'^ACT [0-9]+\. (.+)$', r'\\act\n\n\1', line)

def scenes(line):
    return re.sub(r'SCENE.*', r'\\scene\n', line)

def compose(funs):
    return lambda x: reduce(lambda acc, f: f(acc), funs, x)

def add_wrapper(lines):
    return prefix()+lines+suffix()

def write(lines):
    print('\n'.join(lines))

def prefix():
    return r'''
\documentclass{memoir}
\usepackage{dramatist}
\usepackage{dramatist-mods}

\begin{document}

\Character[Subtle, the Alchemist]{Subtle}{subtle}
\Character[Face, the housekeeper]{Face}{face}
\Character[Dol Common, their colleague]{Dol}{dol}
\Character[Dapper, a lawyer's clerk]{Dapper}{dapper}
\Character[Drugger, a tobacco man]{Drugger}{drugger}
\Character[Lovewit, master of the house]{Lovewit}{lovewit}
\Character[Sir Epicure Mammon, a knight]{Mammon}{mammon}
\Character[Pertinax Surly, a gamester]{Surly}{surly}
\Character[Tribulation Wholesome, a pastor of Amsterdam]{Tribulation}{tribulation}
\Character[Ananias, a deacon there]{Ananias}{ananias}
\Character[Kastril, the angry boy]{Kastril}{kastril}
\Character[Dame Pliant, his sister, a widow]{Pliant}{pliant}
\Character[An officer]{Officer 1}{officerone}
\Character[Another officer]{Officer 2}{officertwo}

\settowidth{\speakswidth}{\speaksfont{Tribulation}\speaksdel\hspace{\Dlabelsep}}
\setlength\speaksindent{0in}

\DramPer


\begin{drama*}

'''.split('\n')

def suffix():
    return r'''
\end{drama*}
\end{document}
'''.split('\n')

if __name__ == '__main__':
    main()
